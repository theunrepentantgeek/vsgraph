using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;

namespace Niche.Graphs
{
    /// <summary>
    /// Immutable representation of a Graph, containing Nodes, Edges and SubGraphs.
    /// </summary>
    public class Graph
    {
        /// <summary>
        /// Gets a sequence of all nodes contained by this graph
        /// </summary>
        public IEnumerable<Node> Nodes
        {
            get
            {
                return mNodes;
            }
        }

        /// <summary>
        /// Gets a sequence of all edges contained by this graph
        /// </summary>
        public IEnumerable<Edge> Edges
        {
            get
            {
                return mEdges;
            }
        }

        /// <summary>
        /// Gets a sequence of all subgraphs contains by this graph
        /// </summary>
        public IEnumerable<Graph> SubGraphs
        {
            get
            {
                return mSubGraphs;
            }
        }

        /// <summary>
        /// Gets a value indicating whether to merge edges
        /// </summary>
        public bool MergeEdges { get; private set; }

        /// <summary>
        /// Gets the orientation to use for the graph.
        /// </summary>
        public Orientation Orientation { get; private set; }

        /// <summary>
        /// Gets the resolution to use for the graph.
        /// </summary>
        public int DotsPerInch { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="Graph"/> class.
        /// </summary>
        /// Note that not all edges will be entirely contained within this graph; inbound
        /// and outbound edges, as well as edges in-to and out-of subgraphs are all legal.
        /// <param name="nodes">The nodes that make up this graph.</param>
        /// <param name="edges">The edges that make up this graph.</param>
        /// <param name="subgraphs">Any contained subgraphs</param>
        /// <param name="style"></param>
        /// <exception cref="ArgumentNullException">
        /// If any argument is missing.
        /// </exception>
        public Graph(IEnumerable<Node> nodes, IEnumerable<Edge> edges, IEnumerable<Graph> subgraphs, GraphStyle style)
        {
            if (nodes == null)
            {
                throw new ArgumentNullException(
                    "nodes",
                    "Sequence of nodes must be supplied (but may be empty)");
            }

            if (edges == null)
            {
                throw new ArgumentNullException(
                    "edges",
                    "Sequence of Edges must be supplied (but may be empty)");
            }

            if (subgraphs == null)
            {
                throw new ArgumentNullException(
                    "subgraphs",
                    "Sequence of subgraphs must be supplied (but may be empty)");
            }

            mNodes = new List<Node>(nodes).AsReadOnly();
            mEdges = new List<Edge>(edges).AsReadOnly();
            mSubGraphs = new List<Graph>(subgraphs).AsReadOnly();

            if (style != null)
            {
                MergeEdges = style.MergeEdges;
                Orientation = style.Orientation;
                DotsPerInch = style.DotsPerInch;
            }
        }

        /// <summary>
        /// Pass in a visitor to be visited by this graph and its child elements
        /// </summary>
        /// <typeparam name="TReturn">Return type of this visitor</typeparam>
        /// <param name="visitor">Visitor to visit</param>
        /// <returns>Result generated by the visitor.</returns>
        public TReturn Visit<TReturn>(IGraphVisitor<TReturn> visitor)
            where TReturn : class
        {
            if (visitor == null)
            {
                throw new ArgumentNullException("visitor", "Must have a visitor to approach.");
            }

            var nodeResults
                = Nodes.Select(n => n.Visit(visitor))
                    .ToList();

            var edgeResults
                = Edges.Select(e => e.Visit(visitor))
                    .ToList();

            var subGraphResults
                = SubGraphs.Select(g => g.Visit(visitor))
                    .ToList();

            return visitor.VisitGraph(this, nodeResults, edgeResults, subGraphResults);
        }

        /// <summary>
        /// Storage for the Nodes property
        /// </summary>
        private readonly ReadOnlyCollection<Node> mNodes;

        /// <summary>
        /// Storage for the Edges property.
        /// </summary>
        private readonly IEnumerable<Edge> mEdges;

        /// <summary>
        /// Storage for the SubGraphs property
        /// </summary>
        private readonly IEnumerable<Graph> mSubGraphs;
    }
}
